import { useState, useEffect, useRef } from 'react';
import { Room, RemoteParticipant, LocalParticipant, ConnectionState, Track, AudioPresets, TrackPublication } from 'livekit-client';
import { Socket } from 'socket.io-client';

export interface CallData {
    callerId: string;
    receiverId: string;
    callerName: string;
    receiverName?: string;
    roomName: string;
    callType: 'audio' | 'video';
}

export type CallStatus = 'idle' | 'calling' | 'ringing' | 'connected' | 'rejected' | 'ended' | 'connecting' | 'timeout' | 'busy' | 'unavailable';

// Debug function to check available media devices
const checkMediaDevices = async () => {
    try {
        // Check secure context (HTTPS required for getUserMedia)
        if (!window.isSecureContext) {
            console.warn('‚ö†Ô∏è Not in secure context (HTTPS required for microphone access)');
        }

        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        const videoInputs = devices.filter(device => device.kind === 'videoinput');

        console.log('üì± Available media devices:', {
            audioInputs: audioInputs.length,
            videoInputs: videoInputs.length,
            isSecureContext: window.isSecureContext,
            devices: devices.map(d => ({ kind: d.kind, label: d.label || 'Unknown device' }))
        });

        return { audioInputs, videoInputs };
    } catch (error) {
        console.error('‚ùå Error checking media devices:', error);
        return { audioInputs: [], videoInputs: [] };
    }
};

export const useCall = (socket: Socket | null, currentUserId: string, currentUserName?: string) => {
    const [room, setRoom] = useState<Room | null>(null);
    const [isInCall, setIsInCall] = useState(false);
    const [incomingCall, setIncomingCall] = useState<CallData | null>(null);
    const [callStatus, setCallStatus] = useState<CallStatus>('idle');
    const [localParticipant, setLocalParticipant] = useState<LocalParticipant | null>(null);
    const [remoteParticipants, setRemoteParticipants] = useState<RemoteParticipant[]>([]);
    const [connectionState, setConnectionState] = useState<ConnectionState>(ConnectionState.Disconnected);
    const [autoEndMessage, setAutoEndMessage] = useState<string | null>(null);
    const [callEndReason, setCallEndReason] = useState<string | null>(null);
    const [callType, setCallType] = useState<'audio' | 'video'>('video');

    // Enhanced user name management
    const [callerName, setCallerName] = useState<string | null>(null);
    const [receiverName, setReceiverName] = useState<string | null>(null);
    const [isInitiator, setIsInitiator] = useState<boolean>(false);

    const roomRef = useRef<Room | null>(null);
    const autoEndTimerRef = useRef<NodeJS.Timeout | null>(null);
    const callStartTimeRef = useRef<number | null>(null);

    // Utility function ƒë·ªÉ l·∫•y t√™n ng∆∞·ªùi d√πng t·ª´ ph√≠a b√™n kia
    const getRemoteUserName = () => {
        if (isInitiator) {
            // N·∫øu l√† ng∆∞·ªùi g·ªçi, remote user l√† ng∆∞·ªùi nh·∫≠n
            return receiverName || 'Ng∆∞·ªùi d√πng';
        } else {
            // N·∫øu l√† ng∆∞·ªùi nh·∫≠n, remote user l√† ng∆∞·ªùi g·ªçi
            return callerName || 'Ng∆∞·ªùi d√πng';
        }
    };

    // Auto-end timer functions
    const startAutoEndTimer = () => {
        console.log('üïê Starting auto-end timer (2 minutes)...');
        if (autoEndTimerRef.current) {
            clearTimeout(autoEndTimerRef.current);
        }
        autoEndTimerRef.current = setTimeout(() => {
            console.log('‚è∞ Auto-ending call after 2 minutes of waiting...');
            setAutoEndMessage('Cu·ªôc g·ªçi ƒë√£ t·ª± ƒë·ªông k·∫øt th√∫c sau 2 ph√∫t ch·ªù ƒë·ª£i');
            setCallEndReason('Kh√¥ng c√≥ ng∆∞·ªùi tham gia trong 2 ph√∫t');
            endCall('timeout');
        }, 2 * 60 * 1000);
    };

    const stopAutoEndTimer = () => {
        console.log('üõë Stopping auto-end timer...');
        if (autoEndTimerRef.current) {
            clearTimeout(autoEndTimerRef.current);
            autoEndTimerRef.current = null;
        }
    };

    const manageAutoEndTimer = (remoteCount: number) => {
        if (remoteCount === 0) {
            if (!autoEndTimerRef.current) {
                startAutoEndTimer();
            }
        } else {
            stopAutoEndTimer();
        }
    };

    // Media permissions request
    const requestMediaPermissions = async (type: 'audio' | 'video'): Promise<boolean> => {
        try {
            console.log(`üé• Requesting ${type} permissions...`);
            const constraints: MediaStreamConstraints = {
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            };

            if (type === 'video') {
                constraints.video = {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user'
                };
            }

            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            console.log(`‚úÖ ${type} permissions granted, stream tracks:`, stream.getTracks().map(t => t.kind));
            stream.getTracks().forEach(track => track.stop());
            return true;
        } catch (error) {
            console.error(`‚ùå Error requesting ${type} permissions:`, error);
            if (error instanceof Error) {
                if (error.name === 'NotAllowedError') {
                    const mediaType = type === 'video' ? 'camera v√† microphone' : 'microphone';
                    alert(`Vui l√≤ng cho ph√©p truy c·∫≠p ${mediaType} ƒë·ªÉ th·ª±c hi·ªán cu·ªôc g·ªçi`);
                } else if (error.name === 'NotFoundError') {
                    const mediaType = type === 'video' ? 'camera ho·∫∑c microphone' : 'microphone';
                    alert(`Kh√¥ng t√¨m th·∫•y ${mediaType}`);
                } else if (error.name === 'NotReadableError') {
                    const mediaType = type === 'video' ? 'Camera ho·∫∑c microphone' : 'Microphone';
                    alert(`${mediaType} ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ·ª©ng d·ª•ng kh√°c`);
                }
            }
            return false;
        }
    };

    // Socket event listeners v·ªõi qu·∫£n l√Ω t√™n ch√≠nh x√°c
    useEffect(() => {
        if (!socket || !currentUserId) return;

        const handleIncomingCall = (callData: CallData) => {
            console.log('üìû Incoming call from:', callData.callerName, 'Type:', callData.callType);
            setIncomingCall(callData);
            setCallStatus('ringing');
            setCallType(callData.callType);

            // Set names correctly for incoming call
            setCallerName(callData.callerName);
            setReceiverName(currentUserName || 'B·∫°n');
            setIsInitiator(false); // ƒê√¢y l√† ng∆∞·ªùi nh·∫≠n
        };

        const handleCallAccepted = async (callData: CallData) => {
            console.log('‚úÖ Call accepted, connecting to room:', callData.roomName, 'Type:', callData.callType);
            setCallStatus('connected');
            setCallType(callData.callType);

            // Update receiver name when call is accepted
            if (callData.receiverName && isInitiator) {
                setReceiverName(callData.receiverName);
            }
        };

        const handleCallRejected = (data: { reason: string; message: string; callType?: string }) => {
            console.log('‚ùå Call rejected:', data.message, 'Type:', data.callType);
            setCallStatus('rejected');
            setIncomingCall(null);

            const reasonMessages = {
                busy: 'Ng∆∞·ªùi d√πng ƒëang b·∫≠n',
                declined: 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi',
                unavailable: 'Ng∆∞·ªùi d√πng kh√¥ng c√≥ s·∫µn'
            };
            setCallEndReason(reasonMessages[data.reason as keyof typeof reasonMessages] || 'Cu·ªôc g·ªçi kh√¥ng th√†nh c√¥ng');

            if (roomRef.current) {
                roomRef.current.disconnect();
                roomRef.current = null;
                setRoom(null);
            }

            stopAutoEndTimer();
            resetCallState();

            setTimeout(() => {
                setCallStatus('idle');
                setCallEndReason(null);
            }, 3000);
        };

        const handleCallEnded = (data: any) => {
            console.log('üìû Call ended by:', data.endedBy, 'Type:', data.callType);
            if (data.reason === 'timeout') {
                setCallEndReason('Ng∆∞·ªùi d√πng ƒë√£ ng·∫Øt k·∫øt n·ªëi');
            } else if (data.reason === 'disconnect') {
                setCallEndReason('M·∫•t k·∫øt n·ªëi v·ªõi ng∆∞·ªùi d√πng');
            } else {
                setCallEndReason('Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c');
            }
            endCall();
        };

        const handleCallTimeout = () => {
            console.log('‚è∞ Call timeout received from server');
            setAutoEndMessage('Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ ng∆∞·ªùi nh·∫≠n');
            setCallEndReason('Kh√¥ng c√≥ ph·∫£n h·ªìi');
            endCall('timeout');
        };

        socket.on('incomingCall', handleIncomingCall);
        socket.on('callAccepted', handleCallAccepted);
        socket.on('callRejected', handleCallRejected);
        socket.on('callEnded', handleCallEnded);
        socket.on('callTimeout', handleCallTimeout);

        socket.on('callStatusChange', (data: { type: string; message?: string; callType?: string }) => {
            console.log('üì° Call status change:', data);
            if (data.type === 'timeout') {
                setAutoEndMessage(data.message || 'Cu·ªôc g·ªçi ƒë√£ h·∫øt th·ªùi gian');
                setCallEndReason('H·∫øt th·ªùi gian ch·ªù');
                endCall('timeout');
            }
        });

        return () => {
            socket.off('incomingCall', handleIncomingCall);
            socket.off('callAccepted', handleCallAccepted);
            socket.off('callRejected', handleCallRejected);
            socket.off('callEnded', handleCallEnded);
            socket.off('callTimeout', handleCallTimeout);
            socket.off('callStatusChange');
        };
    }, [socket, currentUserId, currentUserName]);

    // Reset call state helper
    const resetCallState = () => {
        setCallerName(null);
        setReceiverName(null);
        setIsInitiator(false);
    };

    // Room events setup
    const setupRoomEvents = (roomInstance: Room) => {
        console.log('üè† Setting up room events...');

        roomInstance.on('connected', () => {
            console.log('‚úÖ Connected to LiveKit room');
            setConnectionState(ConnectionState.Connected);
            setIsInCall(true);
            setCallStatus('connected');
            callStartTimeRef.current = Date.now();

            setLocalParticipant(roomInstance.localParticipant);
            const remotes = Array.from(roomInstance.remoteParticipants.values());
            setRemoteParticipants(remotes);

            manageAutoEndTimer(remotes.length);

            console.log(`üè† Room connected. Local: ${roomInstance.localParticipant.identity}, Remotes found: ${roomInstance.numParticipants}`);
        });

        roomInstance.on('disconnected', () => {
            console.log('‚ùå Disconnected from LiveKit room');
            setConnectionState(ConnectionState.Disconnected);
            setIsInCall(false);
            setLocalParticipant(null);
            setRemoteParticipants([]);
            stopAutoEndTimer();
        });

        roomInstance.on('participantConnected', (participant: RemoteParticipant) => {
            console.log('üë§ Participant connected:', participant.identity);
            setRemoteParticipants(prev => {
                const newParticipants = [...prev, participant];
                manageAutoEndTimer(newParticipants.length);
                return newParticipants;
            });
            setCallStatus('connected');
        });

        roomInstance.on('participantDisconnected', (participant: RemoteParticipant) => {
            console.log('üë§ Participant disconnected:', participant.identity);
            setRemoteParticipants(prev => {
                const newParticipants = prev.filter(p => p.identity !== participant.identity);
                manageAutoEndTimer(newParticipants.length);
                return newParticipants;
            });

            setCallEndReason('Ng∆∞·ªùi d√πng ƒë√£ r·ªùi cu·ªôc g·ªçi');
        });

        roomInstance.on('trackSubscribed', (track, publication, participant) => {
            console.log('üì° Track subscribed:', track.kind, 'from', participant.identity);

            if (track.kind === 'audio') {
                console.log('üîä Audio track subscribed from:', participant.identity);

                // ƒê·∫£m b·∫£o audio track ƒë∆∞·ª£c play
                const audioElement = track.attach();
                audioElement.volume = 1.0;
                audioElement.muted = false;

                // Force play with user interaction fallback
                const playAudio = async () => {
                    try {
                        await audioElement.play();
                        console.log('‚úÖ Audio playing successfully from:', participant.identity);
                    } catch (error) {
                        console.error('‚ùå Error playing audio from', participant.identity, ':', error);

                        // Retry after user interaction
                        const handleUserInteraction = async () => {
                            try {
                                await audioElement.play();
                                console.log('‚úÖ Audio playing after user interaction from:', participant.identity);
                                document.removeEventListener('click', handleUserInteraction);
                                document.removeEventListener('touchstart', handleUserInteraction);
                            } catch (retryError) {
                                console.error('‚ùå Still failed to play audio:', retryError);
                            }
                        };

                        document.addEventListener('click', handleUserInteraction, { once: true });
                        document.addEventListener('touchstart', handleUserInteraction, { once: true });
                    }
                };

                playAudio();
            }
        });

        roomInstance.on('trackUnsubscribed', (track, publication, participant) => {
            console.log('üì° Track unsubscribed:', track.kind, 'from', participant.identity);

            if (track.kind === 'audio') {
                console.log('üîá Audio track unsubscribed from:', participant.identity);
            }
        });

        // Track published event
        roomInstance.on('trackPublished', (publication, participant) => {
            console.log('üì¢ Track published:', publication.kind, 'from', participant.identity);

            if (publication.kind === 'audio') {
                console.log('üé§ Audio track published by:', participant.identity);
            }
        });

        // Track unpublished event  
        roomInstance.on('trackUnpublished', (publication, participant) => {
            console.log('üì¢ Track unpublished:', publication.kind, 'from', participant.identity);

            if (publication.kind === 'audio') {
                console.log('üé§ Audio track unpublished by:', participant.identity);
            }
        });
    };

    // Initiate call function v·ªõi enhanced name management
    const initiateCall = async (
        receiverId: string,
        receiverDisplayName: string,
        callerDisplayName: string,
        type: 'audio' | 'video' = 'video'
    ) => {
        if (!socket || !currentUserId) {
            console.error('‚ùå Socket not connected or user not available');
            return { success: false, error: 'Connection error' };
        }

        try {
            console.log(`üìû Initiating ${type} call:`, {
                from: callerDisplayName,
                to: receiverDisplayName,
                callerId: currentUserId,
                receiverId: receiverId
            });

            setCallStatus('calling');
            setCallType(type);

            // Set names correctly for outgoing call
            setCallerName(callerDisplayName);
            setReceiverName(receiverDisplayName);
            setIsInitiator(true); // ƒê√¢y l√† ng∆∞·ªùi g·ªçi

            setAutoEndMessage(null);
            setCallEndReason(null);

            const hasPermissions = await requestMediaPermissions(type);
            if (!hasPermissions) {
                setCallStatus('idle');
                resetCallState();
                return { success: false, error: 'Kh√¥ng th·ªÉ truy c·∫≠p media' };
            }

            const response = await fetch('/api/call/initiate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    callerId: currentUserId,
                    receiverId,
                    callerName: callerDisplayName,
                    callType: type
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API call failed: ${response.status} ${errorText}`);
            }

            const { roomName, token, wsUrl } = await response.json();
            console.log('‚úÖ API response received:', { roomName, wsUrl: wsUrl ? 'present' : 'missing' });

            const roomInstance = new Room({
                adaptiveStream: true,
                dynacast: true,
                publishDefaults: {
                    stopMicTrackOnMute: false,
                    videoCodec: 'vp8',
                    audioPreset: AudioPresets.music,
                },
                videoCaptureDefaults: type === 'video' ? {
                    resolution: { width: 1280, height: 720 },
                    facingMode: 'user'
                } : undefined,
                audioCaptureDefaults: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 48000,
                    channelCount: 1
                }
            });

            roomRef.current = roomInstance;
            setRoom(roomInstance);

            setupRoomEvents(roomInstance);

            console.log('üîó Connecting to LiveKit room...');
            setCallStatus('connecting');

            await roomInstance.connect(wsUrl, token);
            console.log('‚úÖ Connected to LiveKit room successfully');

            setLocalParticipant(roomInstance.localParticipant);

            try {
                console.log(`üé• Requesting ${type} media permissions...`);

                // Check browser support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng g·ªçi tho·∫°i/video. Vui l√≤ng c·∫≠p nh·∫≠t tr√¨nh duy·ªát.');
                }

                // Debug: Check available devices
                await checkMediaDevices();

                // Request microphone permission first
                try {
                    await navigator.mediaDevices.getUserMedia({
                        audio: true,
                        video: type === 'video'
                    });
                    console.log('üé§ Media permissions granted');
                } catch (permissionError: any) {
                    console.error('‚ùå Media permission denied:', permissionError);
                    if (permissionError?.name === 'NotAllowedError') {
                        throw new Error('C·∫ßn c·∫•p quy·ªÅn truy c·∫≠p microphone v√† camera ƒë·ªÉ th·ª±c hi·ªán cu·ªôc g·ªçi');
                    } else if (permissionError?.name === 'NotFoundError') {
                        throw new Error('Kh√¥ng t√¨m th·∫•y microphone ho·∫∑c camera tr√™n thi·∫øt b·ªã');
                    } else {
                        throw new Error('Kh√¥ng th·ªÉ truy c·∫≠p microphone/camera: ' + (permissionError?.message || 'Unknown error'));
                    }
                }

                console.log(`üé• Enabling ${type} media...`);

                // Enable microphone with verification
                await roomInstance.localParticipant.setMicrophoneEnabled(true);
                console.log('üé§ Microphone enabled, checking publication...');

                // Wait for track to be published
                await new Promise(resolve => setTimeout(resolve, 500));

                // Verify microphone track is published
                const micPublication = roomInstance.localParticipant.getTrackPublication(Track.Source.Microphone);
                if (micPublication) {
                    console.log('‚úÖ Microphone track found and published');
                    console.log('üé§ Microphone publication details:', {
                        kind: micPublication.kind,
                        muted: micPublication.isMuted,
                        enabled: micPublication.isEnabled
                    });
                } else {
                    console.warn('‚ö†Ô∏è Microphone track not found after enabling');
                    // Try to force enable again
                    console.log('üîÑ Retrying microphone enable...');
                    await roomInstance.localParticipant.setMicrophoneEnabled(false);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await roomInstance.localParticipant.setMicrophoneEnabled(true);
                }

                if (type === 'video') {
                    await roomInstance.localParticipant.setCameraEnabled(true);
                } else {
                    await roomInstance.localParticipant.setCameraEnabled(false);
                }

                // Log all published tracks
                const publications = Array.from(roomInstance.localParticipant.trackPublications.values());
                console.log('üìä Local published tracks:', publications.map(p => p.kind));

                console.log(`‚úÖ ${type} media enabled successfully`);
            } catch (enableError) {
                console.error('‚ùå Error enabling media:', enableError);
                throw enableError;
            }

            console.log('üì§ Sending call notification via socket...');
            socket.emit('initiateCall', {
                receiverId,
                callData: {
                    callerId: currentUserId,
                    receiverId,
                    callerName: callerDisplayName,
                    receiverName: receiverDisplayName,
                    roomName,
                    callType: type
                }
            });

            console.log(`‚úÖ ${type} call initiated successfully`);
            return { success: true, roomName };

        } catch (error) {
            console.error('‚ùå Error initiating call:', error);
            setCallStatus('idle');
            resetCallState();

            let errorMessage = 'Kh√¥ng th·ªÉ kh·ªüi t·∫°o cu·ªôc g·ªçi';
            if (error instanceof Error) {
                if (error.message.includes('microphone') || error.message.includes('camera')) {
                    errorMessage = error.message;
                } else if (error.message.includes('Permission')) {
                    errorMessage = 'C·∫ßn c·∫•p quy·ªÅn truy c·∫≠p microphone v√† camera ƒë·ªÉ th·ª±c hi·ªán cu·ªôc g·ªçi';
                }
            }

            setCallEndReason(errorMessage);

            if (roomRef.current) {
                await roomRef.current.disconnect();
                roomRef.current = null;
                setRoom(null);
            }

            stopAutoEndTimer();

            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to initiate call'
            };
        }
    };

    // Accept call function
    const acceptCall = async () => {
        if (!incomingCall || !socket) {
            console.error('‚ùå No incoming call or socket not connected');
            return { success: false, error: 'No incoming call' };
        }

        try {
            console.log(`‚úÖ Accepting ${incomingCall.callType} call from:`, incomingCall.callerName);
            setCallStatus('connecting');
            setCallType(incomingCall.callType);
            setAutoEndMessage(null);
            setCallEndReason(null);

            const hasPermissions = await requestMediaPermissions(incomingCall.callType);
            if (!hasPermissions) {
                setCallEndReason('Kh√¥ng th·ªÉ truy c·∫≠p media');
                rejectCall('unavailable');
                return { success: false, error: 'Kh√¥ng th·ªÉ truy c·∫≠p media' };
            }

            const response = await fetch('/api/call/accept', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    receiverId: currentUserId,
                    roomName: incomingCall.roomName,
                    callerId: incomingCall.callerId,
                    callType: incomingCall.callType
                })
            });

            if (!response.ok) {
                throw new Error('Failed to accept call');
            }

            const { token, wsUrl } = await response.json();

            const roomInstance = new Room({
                adaptiveStream: true,
                dynacast: true,
                publishDefaults: {
                    stopMicTrackOnMute: false,
                    videoCodec: 'vp8',
                    audioPreset: AudioPresets.music,
                },
                videoCaptureDefaults: incomingCall.callType === 'video' ? {
                    resolution: { width: 1280, height: 720 },
                    facingMode: 'user'
                } : undefined,
                audioCaptureDefaults: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 48000,
                    channelCount: 1
                }
            });

            roomRef.current = roomInstance;
            setRoom(roomInstance);

            setupRoomEvents(roomInstance);

            await roomInstance.connect(wsUrl, token);
            setLocalParticipant(roomInstance.localParticipant);

            try {
                console.log(`üé• Requesting ${incomingCall.callType} media permissions...`);

                // Check browser support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng g·ªçi tho·∫°i/video. Vui l√≤ng c·∫≠p nh·∫≠t tr√¨nh duy·ªát.');
                }

                // Debug: Check available devices
                await checkMediaDevices();

                // Request media permissions first
                try {
                    await navigator.mediaDevices.getUserMedia({
                        audio: true,
                        video: incomingCall.callType === 'video'
                    });
                    console.log('üé§ Media permissions granted for call accept');
                } catch (permissionError: any) {
                    console.error('‚ùå Media permission denied during call accept:', permissionError);
                    if (permissionError?.name === 'NotAllowedError') {
                        throw new Error('C·∫ßn c·∫•p quy·ªÅn truy c·∫≠p microphone v√† camera ƒë·ªÉ tham gia cu·ªôc g·ªçi');
                    } else if (permissionError?.name === 'NotFoundError') {
                        throw new Error('Kh√¥ng t√¨m th·∫•y microphone ho·∫∑c camera tr√™n thi·∫øt b·ªã');
                    } else {
                        throw new Error('Kh√¥ng th·ªÉ truy c·∫≠p microphone/camera: ' + (permissionError?.message || 'Unknown error'));
                    }
                }

                // Enable microphone with verification
                await roomInstance.localParticipant.setMicrophoneEnabled(true);
                console.log('üé§ Microphone enabled for call accept, checking publication...');

                // Wait for track to be published
                await new Promise(resolve => setTimeout(resolve, 500));

                // Verify microphone track is published
                const micPublication = roomInstance.localParticipant.getTrackPublication(Track.Source.Microphone);
                if (micPublication) {
                    console.log('‚úÖ Microphone track found and published for call accept');
                    console.log('üé§ Microphone publication details for call accept:', {
                        kind: micPublication.kind,
                        muted: micPublication.isMuted,
                        enabled: micPublication.isEnabled
                    });
                } else {
                    console.warn('‚ö†Ô∏è Microphone track not found after enabling for call accept');
                    // Try to force enable again
                    console.log('üîÑ Retrying microphone enable for call accept...');
                    await roomInstance.localParticipant.setMicrophoneEnabled(false);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await roomInstance.localParticipant.setMicrophoneEnabled(true);
                }

                if (incomingCall.callType === 'video') {
                    await roomInstance.localParticipant.setCameraEnabled(true);
                } else {
                    await roomInstance.localParticipant.setCameraEnabled(false);
                }

                // Log all published tracks
                const publications = Array.from(roomInstance.localParticipant.trackPublications.values());
                console.log('üìä Local published tracks for call accept:', publications.map(p => p.kind));

                console.log(`‚úÖ ${incomingCall.callType} media enabled for call accept`);
            } catch (mediaError) {
                console.error('‚ùå Error setting up media for call accept:', mediaError);
                throw mediaError;
            }

            socket.emit('acceptCall', {
                callerId: incomingCall.callerId,
                callData: {
                    ...incomingCall,
                    receiverId: currentUserId,
                    receiverName: currentUserName || 'B·∫°n'
                }
            });

            setIncomingCall(null);
            console.log(`‚úÖ ${incomingCall.callType} call accepted successfully`);
            return { success: true };

        } catch (error) {
            console.error('‚ùå Error accepting call:', error);
            setCallStatus('idle');
            setIncomingCall(null);
            resetCallState();

            let errorMessage = 'Kh√¥ng th·ªÉ ch·∫•p nh·∫≠n cu·ªôc g·ªçi';
            if (error instanceof Error) {
                if (error.message.includes('microphone') || error.message.includes('camera')) {
                    errorMessage = error.message;
                } else if (error.message.includes('Permission')) {
                    errorMessage = 'C·∫ßn c·∫•p quy·ªÅn truy c·∫≠p microphone v√† camera ƒë·ªÉ tham gia cu·ªôc g·ªçi';
                }
            }

            setCallEndReason(errorMessage);

            if (roomRef.current) {
                await roomRef.current.disconnect();
                roomRef.current = null;
                setRoom(null);
            }

            stopAutoEndTimer();
            return { success: false, error: error instanceof Error ? error.message : 'Failed to accept call' };
        }
    };

    // Reject call function
    const rejectCall = (reason: 'busy' | 'declined' | 'unavailable' = 'declined') => {
        if (!incomingCall || !socket) return;

        console.log('‚ùå Rejecting call, reason:', reason, 'Type:', incomingCall.callType);

        const reasonMessages = {
            busy: 'B·∫°n ƒëang b·∫≠n',
            declined: 'B·∫°n ƒë√£ t·ª´ ch·ªëi cu·ªôc g·ªçi',
            unavailable: 'Kh√¥ng th·ªÉ k·∫øt n·ªëi'
        };

        setCallEndReason(reasonMessages[reason]);

        socket.emit('rejectCall', {
            callerId: incomingCall.callerId,
            reason,
            callType: incomingCall.callType
        });

        setIncomingCall(null);
        setCallStatus('idle');
        resetCallState();
        stopAutoEndTimer();

        setTimeout(() => {
            setCallEndReason(null);
        }, 3000);
    };

    // End call function
    const endCall = async (reason?: 'timeout' | 'manual') => {
        console.log('üìû Ending call...', reason ? `Reason: ${reason}` : '', 'Type:', callType);

        try {
            if (!callEndReason) {
                if (reason === 'timeout') {
                    setCallEndReason('Cu·ªôc g·ªçi ƒë√£ h·∫øt th·ªùi gian');
                } else {
                    setCallEndReason('Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c');
                }
            }

            if (roomRef.current) {
                await roomRef.current.disconnect();
                roomRef.current = null;
            }

            stopAutoEndTimer();

            setRoom(null);
            setIsInCall(false);
            setCallStatus(reason === 'timeout' ? 'timeout' : 'ended');
            setLocalParticipant(null);
            setRemoteParticipants([]);
            setConnectionState(ConnectionState.Disconnected);
            setIncomingCall(null);

            if (socket && currentUserId) {
                socket.emit('endCall', {
                    userId: currentUserId,
                    callData: {
                        endedBy: currentUserId,
                        reason: reason || 'manual',
                        callType: callType
                    }
                });
            }

            // Reset call state after a delay
            setTimeout(() => {
                resetCallState();
            }, 1000);

            setTimeout(() => {
                setCallStatus('idle');
                setAutoEndMessage(null);
                setTimeout(() => {
                    setCallEndReason(null);
                }, 2000);
            }, reason === 'timeout' ? 5000 : 2000);

            console.log(`‚úÖ ${callType} call ended successfully`);
        } catch (error) {
            console.error('‚ùå Error ending call:', error);
        }
    };

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (roomRef.current) {
                roomRef.current.disconnect();
            }
            stopAutoEndTimer();
            resetCallState();
        };
    }, []);

    return {
        // States
        room,
        isInCall,
        incomingCall,
        callStatus,
        localParticipant,
        remoteParticipants,
        connectionState,
        autoEndMessage,
        callEndReason,
        callType,

        // Enhanced name management
        callerName,
        receiverName,
        remoteUserName: getRemoteUserName(),
        isInitiator,

        // Actions
        initiateCall,
        acceptCall,
        rejectCall,
        endCall: () => endCall('manual')
    };
};