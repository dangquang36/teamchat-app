const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const next = require('next');
const { parse } = require('url');

const dev = process.env.NODE_ENV !== 'production';
const nextApp = next({ dev });
const handle = nextApp.getRequestHandler();

const port = process.env.PORT || 3000;

const userSocketMap = {};
const activeRooms = {};

nextApp.prepare().then(() => {
    const app = express();
    const server = http.createServer(app);
    const io = new Server(server, {
        cors: {
            origin: "*",
            methods: ["GET", "POST"]
        }
    });

    // L·∫Øng nghe k·∫øt n·ªëi Socket.IO
    io.on('connection', (socket) => {
        console.log(`‚úÖ Client ƒë√£ k·∫øt n·ªëi: ${socket.id}`);

        // ƒêƒÉng k√Ω user
        socket.on('join', (userId) => {
            userSocketMap[userId] = socket.id;
            console.log(`üë§ User ${userId} joined with socket ${socket.id}`);
            console.log(`üìä Current user map:`, userSocketMap);
        });

        socket.on('privateMessage', ({ recipientId, payload }) => {
            const recipientSocketId = userSocketMap[recipientId];
            if (recipientSocketId) {
                io.to(recipientSocketId).emit('newMessage', payload);
                console.log(`üí¨ Message sent from ${socket.id} to ${recipientId}`);
            }
        });

        // Direct message emoji reaction events
        socket.on('directMessageEmojiReaction', ({ recipientId, chatId, messageId, emoji, userId, userName, timestamp }) => {
            console.log(`üì• SERVER RECEIVED EMOJI: recipientId=${recipientId}, chatId=${chatId}, messageId=${messageId}, emoji=${emoji}, userId=${userId}`);

            console.log(`üîç User socket map status:`, Object.keys(userSocketMap));
            console.log(`üîç Looking for recipient ${recipientId} in map...`);

            const recipientSocketId = userSocketMap[recipientId];
            if (recipientSocketId) {
                console.log(`‚úÖ Found recipient socket: ${recipientSocketId}`);
                io.to(recipientSocketId).emit('directMessageEmojiReaction', {
                    chatId,
                    messageId,
                    emoji,
                    userId,
                    userName,
                    timestamp
                });
                console.log(`üì§ Direct message emoji reaction sent to ${recipientId} (socket: ${recipientSocketId}) for chat ${chatId}`);
            } else {
                console.log(`‚ùå Recipient ${recipientId} not found in userSocketMap:`, userSocketMap);
                console.log(`‚ùå Available users:`, Object.keys(userSocketMap));
            }
        });

        socket.on('sendFriendRequest', ({ recipientId, payload }) => {
            const recipientSocketId = userSocketMap[recipientId];
            if (recipientSocketId) {
                io.to(recipientSocketId).emit('friendRequestReceived', payload);
                console.log(`üë• Friend request sent to ${recipientId}`);
            }
        });

        socket.on('acceptFriendRequest', ({ recipientId, payload }) => {
            const recipientSocketId = userSocketMap[recipientId];
            if (recipientSocketId) {
                io.to(recipientSocketId).emit('friendRequestAccepted', payload);
                console.log(`‚úÖ Friend request accepted by ${recipientId}`);
            }
        });

        // Kh·ªüi t·∫°o cu·ªôc g·ªçi (Enhanced v·ªõi callType)
        socket.on('initiateCall', ({ receiverId, callData }) => {
            const receiverSocketId = userSocketMap[receiverId];
            if (receiverSocketId) {
                // Validate callType
                const callType = callData.callType || 'video';
                const validCallTypes = ['audio', 'video'];

                if (!validCallTypes.includes(callType)) {
                    socket.emit('callStatusChange', {
                        type: 'error',
                        message: 'Lo·∫°i cu·ªôc g·ªçi kh√¥ng h·ª£p l·ªá'
                    });
                    return;
                }

                // L∆∞u th√¥ng tin room v·ªõi callType
                activeRooms[callData.roomName] = {
                    callerId: callData.callerId,
                    receiverId: receiverId,
                    callType: callType,
                    status: 'calling',
                    createdAt: Date.now(),
                    callerSocketId: socket.id,
                    receiverSocketId: receiverSocketId
                };

                // G·ª≠i cu·ªôc g·ªçi ƒë·∫øn cho receiver v·ªõi th√¥ng tin callType
                io.to(receiverSocketId).emit('incomingCall', {
                    ...callData,
                    callType: callType
                });

                console.log(`üìû ${callType} call initiated from ${callData.callerId} to ${receiverId} in room ${callData.roomName}`);

                // G·ª≠i notification v·ªõi lo·∫°i cu·ªôc g·ªçi
                io.to(receiverSocketId).emit('incomingCallNotification', {
                    ...callData,
                    callType: callType
                });

                // G·ª≠i status cho caller
                socket.emit('callStatusChange', {
                    type: 'calling',
                    message: `ƒêang g·ªçi ${callType === 'audio' ? 'tho·∫°i' : 'video'}...`,
                    callType: callType
                });

                // Set timeout ƒë·ªÉ t·ª± ƒë·ªông h·ªßy cu·ªôc g·ªçi sau 30 gi√¢y n·∫øu kh√¥ng ƒë∆∞·ª£c tr·∫£ l·ªùi
                setTimeout(() => {
                    if (activeRooms[callData.roomName] && activeRooms[callData.roomName].status === 'calling') {
                        // Th√¥ng b√°o timeout v·ªõi callType
                        socket.emit('callStatusChange', {
                            type: 'timeout',
                            message: 'Kh√¥ng c√≥ ph·∫£n h·ªìi',
                            callType: callType
                        });

                        io.to(receiverSocketId).emit('callStatusChange', {
                            type: 'timeout',
                            message: 'Cu·ªôc g·ªçi ƒë√£ h·∫øt th·ªùi gian',
                            callType: callType
                        });

                        // Cleanup
                        delete activeRooms[callData.roomName];
                        console.log(`‚è∞ ${callType} call timeout: ${callData.roomName}`);
                    }
                }, 30000); // 30 seconds

            } else {
                socket.emit('callStatusChange', {
                    type: 'error',
                    message: 'Ng∆∞·ªùi d√πng kh√¥ng tr·ª±c tuy·∫øn'
                });
                console.log(`‚ùå Call failed: User ${receiverId} is offline`);
            }
        });

        // Ch·∫•p nh·∫≠n cu·ªôc g·ªçi (Enhanced v·ªõi callType)
        socket.on('acceptCall', ({ callerId, callData }) => {
            const callerSocketId = userSocketMap[callerId];
            if (callerSocketId) {
                const callType = callData.callType || 'video';

                // C·∫≠p nh·∫≠t tr·∫°ng th√°i room
                if (activeRooms[callData.roomName]) {
                    activeRooms[callData.roomName].status = 'connecting';
                    activeRooms[callData.roomName].callType = callType;
                    console.log(`üîÑ Room ${callData.roomName} status: connecting (${callType})`);
                }

                // Th√¥ng b√°o cho caller r·∫±ng cu·ªôc g·ªçi ƒë∆∞·ª£c ch·∫•p nh·∫≠n
                io.to(callerSocketId).emit('callAccepted', {
                    ...callData,
                    callType: callType
                });

                console.log(`‚úÖ ${callType} call accepted by ${callData.receiverId}`);

                // G·ª≠i status connecting cho c·∫£ hai
                socket.emit('callStatusChange', {
                    type: 'connecting',
                    message: 'ƒêang k·∫øt n·ªëi...',
                    callType: callType
                });
                io.to(callerSocketId).emit('callStatusChange', {
                    type: 'connecting',
                    message: 'ƒêang k·∫øt n·ªëi...',
                    callType: callType
                });

                // Th√¥ng b√°o r·∫±ng cu·ªôc g·ªçi ƒë√£ ƒë∆∞·ª£c ch·∫•p nh·∫≠n v√† ƒëang k·∫øt n·ªëi
                io.to(callerSocketId).emit('callConnecting', {
                    roomName: callData.roomName,
                    participants: [callerId, callData.receiverId],
                    callType: callType
                });
                socket.emit('callConnecting', {
                    roomName: callData.roomName,
                    participants: [callerId, callData.receiverId],
                    callType: callType
                });

                // Sau 3 gi√¢y, update status th√†nh connected n·∫øu room v·∫´n t·ªìn t·∫°i
                setTimeout(() => {
                    if (activeRooms[callData.roomName] && activeRooms[callData.roomName].status === 'connecting') {
                        activeRooms[callData.roomName].status = 'connected';

                        // G·ª≠i status connected cho c·∫£ hai
                        socket.emit('callStatusChange', {
                            type: 'connected',
                            message: 'ƒê√£ k·∫øt n·ªëi',
                            callType: callType
                        });
                        io.to(callerSocketId).emit('callStatusChange', {
                            type: 'connected',
                            message: 'ƒê√£ k·∫øt n·ªëi',
                            callType: callType
                        });

                        // Th√¥ng b√°o cu·ªôc g·ªçi ƒë√£ b·∫Øt ƒë·∫ßu
                        io.to(callerSocketId).emit('callStarted', {
                            roomName: callData.roomName,
                            participants: [callerId, callData.receiverId],
                            callType: callType
                        });
                        socket.emit('callStarted', {
                            roomName: callData.roomName,
                            participants: [callerId, callData.receiverId],
                            callType: callType
                        });

                        console.log(`üéâ ${callType} call started successfully: ${callData.roomName}`);
                    }
                }, 3000);
            }
        });

        // T·ª´ ch·ªëi cu·ªôc g·ªçi (Enhanced v·ªõi callType)
        socket.on('rejectCall', ({ callerId, reason }) => {
            const callerSocketId = userSocketMap[callerId];
            if (callerSocketId) {
                const messages = {
                    busy: 'Ng∆∞·ªùi d√πng ƒëang b·∫≠n',
                    declined: 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi',
                    unavailable: 'Kh√¥ng th·ªÉ k·∫øt n·ªëi'
                };

                let callType = 'video'; // default

                // Cleanup room v√† l·∫•y callType
                Object.keys(activeRooms).forEach(roomName => {
                    const room = activeRooms[roomName];
                    if (room.callerId === callerId) {
                        callType = room.callType || 'video';
                        console.log(`üóëÔ∏è Cleaning up rejected ${callType} room: ${roomName}`);
                        delete activeRooms[roomName];
                    }
                });

                // Th√¥ng b√°o cho caller v·ªõi callType
                io.to(callerSocketId).emit('callRejected', {
                    reason,
                    message: messages[reason] || messages.declined,
                    callType: callType
                });

                // Send status change notification v·ªõi callType
                io.to(callerSocketId).emit('callStatusChange', {
                    type: 'rejected',
                    message: messages[reason] || messages.declined,
                    callType: callType
                });

                console.log(`‚ùå ${callType} call rejected by receiver, reason: ${reason}`);
            }
        });

        // B√°o c√°o tr·∫°ng th√°i k·∫øt n·ªëi LiveKit (Enhanced v·ªõi callType)
        socket.on('livekitConnected', ({ roomName, userId }) => {
            console.log(`üîó LiveKit connected: ${userId} in room ${roomName}`);

            if (activeRooms[roomName]) {
                const room = activeRooms[roomName];
                const callType = room.callType || 'video';

                // N·∫øu c·∫£ hai ƒë√£ k·∫øt n·ªëi LiveKit
                if (!room.callerLivekitConnected && room.callerId === userId) {
                    room.callerLivekitConnected = true;
                } else if (!room.receiverLivekitConnected && room.receiverId === userId) {
                    room.receiverLivekitConnected = true;
                }

                // N·∫øu c·∫£ hai ƒë√£ k·∫øt n·ªëi, update status
                if (room.callerLivekitConnected && room.receiverLivekitConnected) {
                    room.status = 'connected';

                    // Th√¥ng b√°o cho c·∫£ hai v·ªõi callType
                    if (room.callerSocketId) {
                        io.to(room.callerSocketId).emit('callStatusChange', {
                            type: 'connected',
                            message: 'ƒê√£ k·∫øt n·ªëi',
                            callType: callType
                        });
                    }
                    if (room.receiverSocketId) {
                        io.to(room.receiverSocketId).emit('callStatusChange', {
                            type: 'connected',
                            message: 'ƒê√£ k·∫øt n·ªëi',
                            callType: callType
                        });
                    }

                    console.log(`üéâ Both participants connected to LiveKit: ${roomName} (${callType})`);
                }
            }
        });

        // K·∫øt th√∫c cu·ªôc g·ªçi (Enhanced v·ªõi callType)
        socket.on('endCall', ({ targetUserId, callData, userId }) => {
            console.log(`üìû Call end request from ${userId}`);

            // T√¨m v√† th√¥ng b√°o cho t·∫•t c·∫£ participants
            let targetSockets = [];
            let callType = 'video'; // default

            if (targetUserId) {
                const targetSocketId = userSocketMap[targetUserId];
                if (targetSocketId) {
                    targetSockets.push(targetSocketId);
                }
            }

            // Cleanup active rooms v√† l·∫•y callType
            Object.keys(activeRooms).forEach(roomName => {
                const room = activeRooms[roomName];
                if (room.callerId === userId || room.receiverId === userId) {
                    callType = room.callType || 'video';

                    // Th√¥ng b√°o cho c·∫£ hai participants
                    const callerSocket = userSocketMap[room.callerId];
                    const receiverSocket = userSocketMap[room.receiverId];

                    if (callerSocket && callerSocket !== socket.id) {
                        io.to(callerSocket).emit('callEnded', {
                            endedBy: userId,
                            roomName: roomName,
                            callType: callType
                        });
                        io.to(callerSocket).emit('callStatusChange', {
                            type: 'ended',
                            callType: callType
                        });
                    }

                    if (receiverSocket && receiverSocket !== socket.id) {
                        io.to(receiverSocket).emit('callEnded', {
                            endedBy: userId,
                            roomName: roomName,
                            callType: callType
                        });
                        io.to(receiverSocket).emit('callStatusChange', {
                            type: 'ended',
                            callType: callType
                        });
                    }

                    delete activeRooms[roomName];
                    console.log(`üóëÔ∏è Cleaned up ${callType} room: ${roomName}`);
                }
            });

            // G·ª≠i cho target user c·ª• th·ªÉ n·∫øu c√≥
            targetSockets.forEach(socketId => {
                io.to(socketId).emit('callEnded', {
                    ...(callData || { endedBy: userId }),
                    callType: callType
                });
                io.to(socketId).emit('callStatusChange', {
                    type: 'ended',
                    callType: callType
                });
            });

            console.log(`üìû ${callType} call ended by ${userId}`);
        });

        // User status events
        socket.on('userOnline', ({ userId, userInfo }) => {
            userSocketMap[userId] = socket.id;
            console.log(`üü¢ User ${userId} is online:`, userInfo.name);

            // Broadcast to other users that this user is online
            socket.broadcast.emit('userStatusChanged', {
                userId,
                status: 'online',
                userInfo
            });
        });

        // Disconnect event (Enhanced v·ªõi callType cleanup)
        socket.on('disconnect', () => {
            let disconnectedUserId = null;
            for (const userId in userSocketMap) {
                if (userSocketMap[userId] === socket.id) {
                    disconnectedUserId = userId;
                    delete userSocketMap[userId];
                    break;
                }
            }

            if (disconnectedUserId) {
                console.log(`üî¥ User ${disconnectedUserId} disconnected`);

                // Cleanup active rooms v√† th√¥ng b√°o call ended v·ªõi callType
                Object.keys(activeRooms).forEach(roomName => {
                    const room = activeRooms[roomName];
                    if (room.callerId === disconnectedUserId || room.receiverId === disconnectedUserId) {
                        const otherUserId = room.callerId === disconnectedUserId ? room.receiverId : room.callerId;
                        const otherSocket = userSocketMap[otherUserId];
                        const callType = room.callType || 'video';

                        if (otherSocket) {
                            io.to(otherSocket).emit('callEnded', {
                                endedBy: disconnectedUserId,
                                reason: 'disconnect',
                                roomName: roomName,
                                callType: callType
                            });
                            io.to(otherSocket).emit('callStatusChange', {
                                type: 'ended',
                                message: 'Ng∆∞·ªùi d√πng ƒë√£ ng·∫Øt k·∫øt n·ªëi',
                                callType: callType
                            });
                        }

                        delete activeRooms[roomName];
                        console.log(`üóëÔ∏è Cleaned up ${callType} room due to disconnect: ${roomName}`);
                    }
                });

                socket.broadcast.emit('userStatusChanged', {
                    userId: disconnectedUserId,
                    status: 'offline'
                });
            }

            console.log(`‚ùå Client disconnected: ${socket.id}`);
        });

        // Heartbeat ƒë·ªÉ theo d√µi k·∫øt n·ªëi
        socket.on('ping', () => {
            socket.emit('pong');
        });

        // Enhanced call quality reporting
        socket.on('callQualityReport', ({ roomName, userId, qualityData }) => {
            console.log(`üìä Call quality report from ${userId} in room ${roomName}:`, qualityData);

            if (activeRooms[roomName]) {
                const room = activeRooms[roomName];
                const callType = room.callType || 'video';

                // Forward quality data to other participant
                const otherUserId = room.callerId === userId ? room.receiverId : room.callerId;
                const otherSocket = userSocketMap[otherUserId];

                if (otherSocket) {
                    io.to(otherSocket).emit('callQualityUpdate', {
                        fromUser: userId,
                        qualityData: qualityData,
                        callType: callType
                    });
                }
            }
        });

        // Call statistics tracking
        socket.on('callStats', ({ roomName, userId, stats }) => {
            if (activeRooms[roomName]) {
                const room = activeRooms[roomName];
                const callType = room.callType || 'video';

                // Store or process call statistics
                console.log(`üìà Call stats from ${userId} (${callType}):`, {
                    room: roomName,
                    type: callType,
                    stats: stats
                });
            }
        });

        // Channel invitation events
        socket.on('sendChannelInvitation', ({ recipientId, payload }) => {
            console.log(`üîî Sending channel invitation to ${recipientId}:`, payload);
            const recipientSocketId = userSocketMap[recipientId];
            if (recipientSocketId) {
                io.to(recipientSocketId).emit('channelInvitationReceived', payload);
                console.log(`‚úÖ Channel invitation sent successfully to ${recipientId} (socket: ${recipientSocketId})`);
            } else {
                console.log(`‚ùå Recipient ${recipientId} not found or not connected`);
            }
        });

        socket.on('acceptChannelInvitation', ({ inviterId, payload }) => {
            console.log(`‚úÖ Channel invitation accepted by ${payload.inviteeName} for channel ${payload.channelId}`);
            console.log('üìã Server received payload:', payload);

            // Notify inviter
            const inviterSocketId = userSocketMap[inviterId];
            if (inviterSocketId) {
                io.to(inviterSocketId).emit('channelInvitationAccepted', payload);
                console.log(`üì§ Notified inviter ${inviterId}`);
            }

            const newMemberData = {
                id: payload.inviteeId,
                name: payload.inviteeName,
                avatar: payload.inviteeAvatar,
                status: 'online',
                joinedAt: new Date()
            };

            console.log('üë§ Broadcasting new member data:', newMemberData);

            // Broadcast to all users in the channel (for real-time member updates)
            io.emit('channelMemberJoined', {
                channelId: payload.channelId,
                newMember: newMemberData,
                channelData: {
                    name: payload.channelName,
                    image: payload.channelImage // Include channel image for sync
                }
            });
            console.log(`üì¢ Broadcast member joined to all users in channel ${payload.channelId}`);
        });

        socket.on('declineChannelInvitation', ({ inviterId, payload }) => {
            const inviterSocketId = userSocketMap[inviterId];
            if (inviterSocketId) {
                io.to(inviterSocketId).emit('channelInvitationDeclined', payload);
                console.log(`‚ùå Channel invitation declined by ${payload.inviteeName}`);
            }
        });



        // Test simple event handler
        socket.on('testSimple', (data, callback) => {
            console.log('üß™ SERVER: Received testSimple event:', data);
            if (callback && typeof callback === 'function') {
                callback({ success: true, message: 'Simple test worked!' });
                console.log('üß™ SERVER: Sent simple test response');
            }
        });

        // Handle channel info updates
        socket.on('updateChannelInfo', (payload, callback) => {
            console.log('üîÑ SERVER: Channel update received!');
            console.log('üìä SERVER: Payload:', JSON.stringify(payload, null, 2));
            console.log(`üìä SERVER: Channel ID: ${payload?.channelId}`);
            console.log(`üìä SERVER: Updated by: ${payload?.updatedBy?.name}`);
            console.log(`üìä SERVER: Updates:`, payload?.updates);

            const broadcastPayload = {
                channelId: payload.channelId,
                updates: payload.updates,
                updatedBy: payload.updatedBy
            };

            console.log('üì¢ SERVER: Broadcasting to all clients...');
            // Broadcast to all users (they will filter by channelId)
            io.emit('channelInfoUpdated', broadcastPayload);
            console.log(`üì¢ SERVER: Broadcast complete to ${io.engine.clientsCount} clients`);

            // Send acknowledgment back to client
            if (callback && typeof callback === 'function') {
                callback({ success: true, message: 'Channel update broadcasted successfully' });
                console.log('üìù SERVER: Sent acknowledgment to client');
            } else {
                console.log('üìù SERVER: No callback provided');
            }
        });

        // Debug: Log all events received by this socket
        socket.onAny((eventName, ...args) => {
            console.log(`üéØ SERVER: Socket ${socket.id} received event: "${eventName}"`);
            if (eventName === 'updateChannelInfo') {
                console.log(`üéØ SERVER: updateChannelInfo args:`, args);
            }
        });

        // Meeting notification to channel members
        socket.on('notifyChannelMeeting', ({ channelId, meetingData }) => {
            console.log(`üì¢ Meeting notification sent to channel ${channelId}`);
            // Broadcast to all connected users (in a real app, you'd get channel members from database)
            io.emit('meetingNotificationReceived', {
                ...meetingData,
                channelId
            });
        });

        // Channel message events
        socket.on('sendChannelMessage', ({ channelId, message, senderId }) => {
            console.log(`üí¨ Channel message sent to ${channelId} by ${senderId}`);
            console.log(`üìé Message type: ${message.type}`);
            console.log(`üìÅ Has file data: ${!!message.fileData}`);

            if (message.fileData) {
                console.log(`üìã File info: ${message.fileData.name} (${message.fileData.size} bytes)`);
            }

            // Special handling for poll messages
            if (message.type === 'poll' && message.poll) {
                console.log(`üìä Poll message details:`, {
                    pollId: message.poll.id,
                    question: message.poll.question,
                    options: message.poll.options.map(opt => ({ id: opt.id, text: opt.text })),
                    creator: message.poll.createdByName
                });
            }

            console.log(`üì§ Broadcasting to all users EXCEPT sender ${senderId}`);

            // Broadcast to all channel members EXCEPT the sender
            socket.broadcast.emit('channelMessageReceived', { channelId, message });
            console.log(`‚úÖ Message broadcasted to channel ${channelId}`);
        });

        // Channel emoji reaction events
        socket.on('channelEmojiReaction', ({ channelId, messageId, emoji, userId, userName, timestamp }) => {
            console.log(`üòÄ Emoji reaction: ${emoji} added to message ${messageId} in channel ${channelId} by ${userName} (${userId})`);

            // Broadcast to all channel members EXCEPT the sender
            socket.broadcast.emit('channelEmojiReaction', {
                channelId,
                messageId,
                emoji,
                userId,
                userName,
                timestamp
            });

            console.log(`‚úÖ Emoji reaction broadcasted to channel ${channelId}`);
        });

        // Poll vote notification events
        socket.on('pollVoted', (payload) => {
            console.log(`üó≥Ô∏è [Server] Poll vote notification for channel ${payload.channelId}`);
            console.log(`üë§ [Server] Voter: ${payload.voter.name} ${payload.action || 'voted'} for "${payload.optionText}"`);
            console.log(`üìä [Server] Poll: "${payload.pollQuestion}"`);

            // Validate payload
            if (!payload.channelId || !payload.voter || !payload.pollQuestion) {
                console.error(`‚ùå [Server] Invalid poll vote payload:`, payload);
                return;
            }

            console.log(`üì§ [Server] Broadcasting vote notification to all users EXCEPT voter ${payload.voter.id}`);

            // Broadcast vote notification to all channel members EXCEPT the voter
            socket.broadcast.emit('pollVoted', {
                ...payload,
                timestamp: new Date(),
                serverProcessedAt: Date.now()
            });
            console.log(`‚úÖ [Server] Poll vote notification broadcasted to channel ${payload.channelId}`);
        });

        // Poll data update events  
        socket.on('pollUpdated', (payload) => {
            console.log(`üìä [Server] Poll data update for channel ${payload.channelId}`);
            console.log(`üîÑ [Server] Poll ID: ${payload.updatedPoll.id}`);
            console.log(`üìà [Server] Total voters: ${payload.updatedPoll.totalVoters}`);
            console.log(`üîó [Server] Message ID: ${payload.messageId}`);
            console.log(`‚è∞ [Server] Timestamp: ${payload.timestamp}`);

            // Validate payload
            if (!payload.channelId || !payload.messageId || !payload.updatedPoll || !payload.updatedPoll.id) {
                console.error(`‚ùå [Server] Invalid poll update payload:`, payload);
                return;
            }

            console.log(`üì§ [Server] Broadcasting poll update to all users EXCEPT sender`);

            // Enhanced payload with server metadata
            const enhancedPayload = {
                ...payload,
                serverProcessedAt: Date.now(),
                timestamp: payload.timestamp || new Date()
            };

            // Broadcast poll data update to all channel members EXCEPT the sender
            socket.broadcast.emit('pollUpdated', enhancedPayload);
            console.log(`‚úÖ [Server] Poll data update broadcasted to channel ${payload.channelId}`);
            console.log(`üìã [Server] Poll options summary:`, payload.updatedPoll.options.map(opt => ({
                text: opt.text,
                votes: opt.votes.length
            })));
        });

        // Test connection event
        socket.on('testConnection', ({ userId }) => {
            console.log(`üß™ Test connection for user ${userId}, socket ${socket.id}`);
            const socketId = userSocketMap[userId];
            console.log(`üìã User ${userId} mapped to socket ${socketId}`);
            console.log(`üìä Current userSocketMap:`, userSocketMap);
        });

        // Post notification events
        socket.on('postNotificationToChannel', ({ channelId, notification, senderId }) => {
            console.log(`üì¢ Post notification sent to channel ${channelId}`);
            console.log(`üìù Post: "${notification.title}" by ${notification.authorName}`);
            console.log(`üë§ Sender ID: ${senderId}`);

            // Get channel members from ChannelMemberService
            const { ChannelMemberService } = require('./services/channelMemberService');
            const channelMembers = ChannelMemberService.getChannelMemberIds(channelId);

            console.log(`üë• Channel ${channelId} members:`, channelMembers);
            console.log(`üìä All channels in service:`, ChannelMemberService.getAllChannels().map(c => ({ id: c.id, name: c.name, members: c.members.length })));

            // Send notification to ALL channel members INCLUDING the sender
            const recipients = channelMembers;
            console.log(`üì§ Sending to all channel members:`, recipients);

            // Send notification to all channel members INCLUDING the sender
            recipients.forEach(recipientId => {
                const recipientSocketId = userSocketMap[recipientId];
                if (recipientSocketId) {
                    io.to(recipientSocketId).emit('postNotificationReceived', {
                        channelId,
                        notification,
                        timestamp: new Date().toISOString()
                    });
                    console.log(`‚úÖ Sent notification to ${recipientId} (socket: ${recipientSocketId})`);
                } else {
                    console.log(`‚ùå Recipient ${recipientId} not connected`);
                }
            });

            console.log(`‚úÖ Post notification sent to ${recipients.length} channel members`);
        });

        // Public post notification events
        socket.on('publicPostNotification', ({ notification }) => {
            console.log(`üåç Public post notification: "${notification.title}" by ${notification.authorName}`);

            // Broadcast to all connected users EXCEPT the sender to prevent duplicates
            socket.broadcast.emit('publicPostNotificationReceived', {
                notification,
                timestamp: new Date().toISOString()
            });

            console.log(`‚úÖ Public post notification broadcasted to all users`);
        });

    });

    app.all('*', (req, res) => {
        return handle(req, res);
    });

    server.listen(port, (err) => {
        if (err) throw err;
        console.log(`üöÄ Server ready on http://localhost:${port}`);
        console.log(`üìû Enhanced Call system initialized (Audio/Video support)`);
        console.log(`üí¨ Chat system ready`);

        // Enhanced cleanup cho inactive rooms v·ªõi callType logging
        setInterval(() => {
            const now = Date.now();
            Object.keys(activeRooms).forEach(roomName => {
                const room = activeRooms[roomName];
                const callType = room.callType || 'video';

                // Cleanup rooms older than 5 minutes or stuck in calling state for more than 1 minute
                if (now - room.createdAt > 5 * 60 * 1000 ||
                    (room.status === 'calling' && now - room.createdAt > 60 * 1000)) {
                    console.log(`üóëÔ∏è Cleaning up inactive/stuck ${callType} room: ${roomName} (${room.status})`);
                    delete activeRooms[roomName];
                }
            });
        }, 60 * 1000); // Check every minute

        // Log active rooms summary every 5 minutes
        setInterval(() => {
            const totalRooms = Object.keys(activeRooms).length;
            if (totalRooms > 0) {
                const roomTypes = {};
                Object.values(activeRooms).forEach(room => {
                    const type = room.callType || 'video';
                    roomTypes[type] = (roomTypes[type] || 0) + 1;
                });

                console.log(`üìä Active rooms summary: ${totalRooms} total`, roomTypes);
            }
        }, 5 * 60 * 1000);
    });
});